import { isSpecialLang } from 'shiki/core';
import { visit } from 'unist-util-visit';
import { toString } from 'hast-util-to-string';

const InlineCodeHandlers = {
  "tailing-curly-colon": (_tree, node) => {
    const raw = toString(node);
    const match = raw.match(/(.+)\{:([\w-]+)\}$/);
    if (!match)
      return;
    return {
      type: "inline",
      code: match[1] ?? raw,
      lang: match.at(2)
    };
  }
};
const languagePrefix$1 = "language-";
const PreHandler = (_tree, node) => {
  const head = node.children[0];
  if (!head || head.type !== "element" || head.tagName !== "code" || !head.properties) {
    return;
  }
  const classes = head.properties.className;
  const languageClass = Array.isArray(classes) ? classes.find(
    (d) => typeof d === "string" && d.startsWith(languagePrefix$1)
  ) : undefined;
  return {
    type: "pre",
    lang: typeof languageClass === "string" ? languageClass.slice(languagePrefix$1.length) : undefined,
    code: toString(head),
    meta: head.data?.meta ?? head.properties.metastring?.toString() ?? ""
  };
};

const languagePrefix = "language-";
function rehypeShikiFromHighlighter(highlighter, options) {
  const {
    addLanguageClass = false,
    parseMetaString,
    cache,
    defaultLanguage,
    fallbackLanguage,
    onError,
    stripEndNewline = true,
    inline = false,
    lazy = false,
    ...rest
  } = options;
  function highlight(lang, code, metaString = "", meta = {}) {
    const cacheKey = `${lang}:${metaString}:${code}`;
    const cachedValue = cache?.get(cacheKey);
    if (cachedValue) {
      return cachedValue;
    }
    const codeOptions = {
      ...rest,
      lang,
      meta: {
        ...rest.meta,
        ...meta,
        __raw: metaString
      }
    };
    if (addLanguageClass) {
      codeOptions.transformers = [
        ...codeOptions.transformers ?? [],
        {
          name: "rehype-shiki:code-language-class",
          code(node) {
            this.addClassToHast(node, `${languagePrefix}${lang}`);
            return node;
          }
        }
      ];
    }
    if (stripEndNewline && code.endsWith("\n"))
      code = code.slice(0, -1);
    try {
      const fragment = highlighter.codeToHast(code, codeOptions);
      cache?.set(cacheKey, fragment);
      return fragment;
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  }
  return (tree) => {
    const queue = [];
    visit(tree, "element", (node, index, parent) => {
      let handler;
      if (!parent || index == null)
        return;
      if (node.tagName === "pre") {
        handler = PreHandler;
      }
      if (node.tagName === "code" && inline) {
        handler = InlineCodeHandlers[inline];
      }
      if (!handler)
        return;
      const res = handler(tree, node);
      if (!res)
        return;
      let lang;
      let lazyLoad = false;
      if (!res.lang) {
        lang = defaultLanguage;
      } else if (highlighter.getLoadedLanguages().includes(res.lang) || isSpecialLang(res.lang)) {
        lang = res.lang;
      } else if (lazy) {
        lazyLoad = true;
        lang = res.lang;
      } else if (fallbackLanguage) {
        lang = fallbackLanguage;
      }
      if (!lang)
        return;
      const processNode = () => {
        const meta = res.meta ? parseMetaString?.(res.meta, node, tree) : undefined;
        const fragment = highlight(lang, res.code, res.meta, meta ?? {});
        if (!fragment)
          return;
        if (res.type === "inline") {
          const head = fragment.children[0];
          if (head.type === "element" && head.tagName === "pre") {
            head.tagName = "span";
          }
        }
        parent.children[index] = fragment;
      };
      if (lazyLoad) {
        queue.push(highlighter.loadLanguage(lang).then(() => processNode()));
      } else {
        processNode();
      }
      return "skip";
    });
    if (queue.length > 0) {
      async function run() {
        await Promise.all(queue);
      }
      return run();
    }
  };
}

export { rehypeShikiFromHighlighter as default };
